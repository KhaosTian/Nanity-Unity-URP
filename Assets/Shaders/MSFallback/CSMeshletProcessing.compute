#pragma kernel ProcessingMain

#include "MeshletCommon.hlsl"

StructuredBuffer<uint> _VisibleMeshletIndicesBuffer;
RWBuffer<uint> _DrawArgsBuffer;
StructuredBuffer<Meshlet> _MeshletsBuffer;
StructuredBuffer<uint> _MeshletPrimitiveIndicesBuffer;
StructuredBuffer<uint> _MeshletVertexIndicesBuffer;

RWByteAddressBuffer _IndicesBuffer;

uint3 UnpackPrimitive(uint primitive)
{
    return uint3((primitive >> 0) & 0xFF, (primitive >> 8) & 0xFF, (primitive >> 16) & 0xFF);
}

uint3 GetPrimitive(Meshlet m, uint index)
{
    return UnpackPrimitive(_MeshletPrimitiveIndicesBuffer[m.PrimOffset + index]);
}

[numthreads(MS_GROUP_SIZE, 1, 1)]
void ProcessingMain(uint localThreadId : SV_GroupThreadID, uint visibleMeshletIndex : SV_GroupID)
{
    // 检查是否超出可见 meshlet 范围
    uint visibleCount = _DrawArgsBuffer[1];
    if (visibleMeshletIndex >= visibleCount) return;

    // 获取实际的 meshlet 索引和 meshlet 数据
    uint globalMeshletIndex = _VisibleMeshletIndicesBuffer[visibleMeshletIndex];
    Meshlet m = _MeshletsBuffer[globalMeshletIndex];

    if (localThreadId >= MAX_PRIMS) return;
    
    uint3 localTri = GetPrimitive(m, localThreadId); // 获取局部三角形索引
    uint baseVtx0 = _MeshletVertexIndicesBuffer[m.VertOffset + localTri.x];
    uint baseVtx1 = _MeshletVertexIndicesBuffer[m.VertOffset + localTri.y];
    uint baseVtx2 = _MeshletVertexIndicesBuffer[m.VertOffset + localTri.z];

    // 写入全局三角形索引缓冲区
    uint baseAddr = 3 * (MAX_PRIMS * visibleMeshletIndex + localThreadId);
    _IndicesBuffer.Store((baseAddr + 0) * 4, localThreadId < m.PrimCount ? baseVtx0 : 0xffff);
    _IndicesBuffer.Store((baseAddr + 1) * 4, localThreadId < m.PrimCount ? baseVtx1 : 0xffff);
    _IndicesBuffer.Store((baseAddr + 2) * 4, localThreadId < m.PrimCount ? baseVtx2 : 0xffff);
}
